'use strict';

const REPLACE_ME = null;

// Using your knowledge of Array methods, fill in the following tests.

module.exports = {

  // predict what ["A", "B", "C"].concat([1, 2, 3]) will return
  concat: REPLACE_ME,


  // predict what ["A", "B", "C"].join() will return
  join: REPLACE_ME,


  // predict what ["A", "B", "C"].push("D") will return
  push: REPLACE_ME,


  // predict what ["A", "B", "C"].pop() will return
  pop: REPLACE_ME,


  // predict what ["A", "B", "C"].shift() will return
  shift: REPLACE_ME,


  // predict what ["A", "B", "C"].unshift("X") will return
  unshift: REPLACE_ME,


  // predict what ["one","two", "three", "four"].slice(0,2) will return
  slice1: REPLACE_ME,


  // predict what ["one","two", "three", "four"].slice(0) will return
  slice2: REPLACE_ME,


  // predict what ["one","two", "three", "four"].slice(-2) will return
  slice3: REPLACE_ME,


  // predict what ["one","two", "three", "four"].splice(1, 2, 3, 4) will return
  splice: REPLACE_ME,


  // predict what ["one","two", "three", "four"].reverse() will return
  reverse: REPLACE_ME,


  // predict what ["BAT", "CAT", "ARTICHOKE"].sort() will return
  sort1: REPLACE_ME,


  // predict what [1, 9, 3, 100, 800, 20].sort() will return
  sort2: REPLACE_ME,


  // predict what ["A", "B", "X", "Z"].indexOf("X") will return
  indexOf1: REPLACE_ME,


  // predict what ["A", "B", "X", "Z"].indexOf("Y") will return
  indexOf2: REPLACE_ME,


  // predict what [1, 4, 9].map(n => n * 3) will return
  map: REPLACE_ME,


  // predict what [1, 40, 900, 60, 300].filter(n => n < 300) will return
  filter: REPLACE_ME,


  // predict what [10, 9, 8, 7].every(n => n < 15) will return
  every: REPLACE_ME,


  // predict what 400, 243, 86, 138, 302].some(n => n < 100) will return
  some: REPLACE_ME,


  // predict what ['S', 'T', 'A', 'R'].reduce((a, b) => a + b) will return
  reduce: REPLACE_ME,


  // predict what ['S', 'T', 'A', 'R'].reduceRight((a, b) => a + b) will return
  reduceRight: REPLACE_ME
};
